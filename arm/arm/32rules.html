<!doctype html public "-//W3C//DTD HTML 3.2//EN">

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta http-equiv="Content-Language" content="zh-cn">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../global.css">
<title>32 位规则</title>
</head>

<!--  /assembler/32rules.html            -->
<!--                                     -->
<!--  (C) Copyright 2001 Richard Murray  -->
<!--  Designed by Richard Murray         -->
<!--  rmurray@heyrick.co.uk              -->
<!--                                     -->

<body TopMargin=0 bgcolor="#f0f0f0" text="#000000" link="#0022dd" vlink="#002288">
<!-- embest help header -->
<img src="../arm.gif" width=778 height=73 border=0>
<!-- embest help header -->
<table border="0" width="100%">
  <tr>
    <td align="center" width="100"></td>
    <td>
      <h1 align="center"><font color="#202020">32 位规则</font></h1>
    </td>
    <td align="center" width="100"></td>
</table>
<p>　
<ul>
  <li>不要使用有 P 后缀的测试指令: TEQP、TSTP、CMPP、CMNP。
  <li>检查更改 PC、R14 的如 BIC 和 ORR 
    这样的指令，和把一个寄存器复制到 PC 的指令。例如，<code>ORRS 
    PC, R14, #1&lt;&lt;28</code> 将不能工作。实际上，不要使用带 S 
    标志设置的写到 PC 的任何指令。
  <li>在数据处理操作中不要使用 R15 (PC) 作为移位寄存器。
  <li>在 LDR/STR 中，不要使用 PC 
    作为寄存器偏移量并不要写回到它。
  <li>在过后变址 LDR/STR 中，Rm(变址)和 Rn(基址)不能是同一个寄存器。类似的，对于涉及写回的任何指令，Rm 
    和 Rn 都应该是不同的寄存器。
  <li>LDM/STM 在用户模式下不使用 S 位。这意味着，不要使用‘^’后缀(例如 
    <code>LDMFD R13!, {PC}^</code>)。
  <li>BL 
    不保存状态寄存器。这必须显式的进行，但是这样的代码将不能在 
    ARM2 或 ARM3 上运行，因为它们不支持 MRS/MSR 指令。
  <li>还要注意，<b>不可能</b>见到被调用者的标志，所以不应该恢复你不知道其状态的标志。你能做的最好的就是在进入的时候保护标志。</li>
</ul>
<p>　
<p>任何带 S 位设置的到 R15 的 32-bit 写(MOVS、ORRS、TEQP、LDM...^) 
将传送当前模式的 SPSR 到 CPSR 中。例如，假定我们在 irq_32 
模式下:
<pre>  MOVS PC, R14</pre>
将复制 R14 到 PC，并接着复制 SPSR_IRQ32 到 CPSR。
<p>这在 USR 模式下不是非常有用因为它没有 SPSR!
<p>&nbsp;
<hr size="3">
<a href="index.html">回到目录页</a>


</body>

</html>
