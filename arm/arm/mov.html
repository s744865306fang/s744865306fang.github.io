<!doctype html public "-//W3C//DTD HTML 3.2//EN">

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta http-equiv="Content-Language" content="zh-cn">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../global.css">
<title>算术和逻辑指令</title>
</head>

<body TopMargin=0 bgcolor="#f0f0f0" text="#000000" link="#0022dd" vlink="#002288">
<!-- embest help header -->
<img src="../arm.gif" width=778 height=73 border=0>
<!-- embest help header -->
    
<table border="0" width="100%">
  <tr>
    <td align="center" width="100"></td>
    <td>
      <h1 align="center"><font color="#202020">算术和逻辑指令</font></h1>
    </td>
    <td align="center" width="100"></td>
</table>
<ul>
  <li><a href="#adc">ADC</a></li>
  <li><a href="#add">ADD</a></li>
  <li><a href="#and">AND</a></li>
  <li><a href="#bic">BIC</a></li>
  <li><a href="#eor">EOR</a></li>
  <li><a href="#mov">MOV</a></li>
  <li><a href="#mvn">MVN</a></li>
  <li><a href="#orr">ORR</a></li>
  <li><a href="#rsb">RSB</a></li>
  <li><a href="#rsc">RSC</a></li>
  <li><a href="#sbc">SBC</a></li>
  <li><a href="#sub">SUB</a></li>
</ul>
<p><a href="ARMinstrs.html#Data">指令格式</a>
<p><a name="adc"></a></p>
<h2>ADC : 带进位的加法</h2>
<p>(<font color="#0000FF">Ad</font>dition with <font color="#0000FF">C</font>arry)</p>
<pre>
  ADC{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 + op_2 + carry
</pre>
<code>ADC</code> 
将把两个操作数加起来，并把结果放置到目的寄存器中。它使用一个进位标志位，这样就可以做比 
32 位大的加法。下列例子将加两个 128 位的数。<br>
128 位结果: 寄存器 0、1、2、和 3<br>
第一个 128 位数: 寄存器 4、5、6、和 7<br>
第二个 128 位数: 寄存器 8、9、10、和 11。
<pre>
  ADDS    R0, R4, R8              ; 加低端的字
  ADCS    R1, R5, R9              ; 加下一个字，带进位
  ADCS    R2, R6, R10             ; 加第三个字，带进位
  ADCS    R3, R7, R11             ; 加高端的字，带进位
</pre>
如果如果要做这样的加法，不要忘记设置 S 
后缀来更改进位标志。
<p>&nbsp;　
<p><a name="add"></a>
<h2>ADD : 加法</h2>
<p>(<font color="#0000FF">Add</font>ition)</p>
<pre>
  ADD{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 + op_2
</pre>
<code>ADD</code> 
将把两个操作数加起来，把结果放置到目的寄存器中。操作数 
1 是一个寄存器，操作数 2 
可以是一个寄存器，被移位的寄存器，或一个立即值:
<pre>
  ADD     R0, R1, R2              ; R0 = R1 + R2
  ADD     R0, R1, #256            ; R0 = R1 + 256
  ADD     R0, R2, R3,LSL#1        ; R0 = R2 + (R3 &lt;&lt; 1)
</pre>
加法可以在有符号和无符号数上进行。
<p>　
<p><a name="and"></a>
<h2>AND : 逻辑与</h2>
<p>(logical <font color="#0000FF">AND</font>)</p>
<pre>
  AND{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 AND op_2
</pre>
<code>AND</code> 
将在两个操作数上进行逻辑与，把结果放置到目的寄存器中；对屏蔽你要在上面工作的位很有用。 
操作数 1 是一个寄存器，操作数 2 
可以是一个寄存器，被移位的寄存器，或一个立即值:
<pre>
  AND     R0, R0, #3              ; R0 = 保持 R0 的位 ０ 和 1，丢弃其余的位。
</pre>
AND 的真值表(二者都是 1 则结果为 1):
<pre>
  Op_1   Op_2   结果

  0      0      0
  0      1      0
  1      0      0
  1      1      1
　</pre>
<p><a name="bic"></a>
<h2>BIC : 位清除</h2>
<p>(<font color="#0000FF">Bi</font>t <font color="#0000FF">C</font>lear)</p>
<pre>
  BIC{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 AND (!op_2)
</pre>
<code>BIC</code> 是在一个字中清除位的一种方法，与 OR 
位设置是相反的操作。操作数 2 是一个 32 位位掩码(mask)。如果如果在掩码中设置了某一位，则清除这一位。未设置的掩码位指示此位保持不变。
<pre>
  BIC     R0, R0, #%1011          ; 清除 R0 中的位 0、1、和 3。保持其余的不变。
</pre>
BIC 真值表 :
<pre>  Op_1   Op_2   结果

  0      0      0
  0      1      0
  1      0      1
  1      1      0</pre>
<pre>译注：逻辑表达式为 Op_1 AND NOT Op_2</pre>
<p>　</p>
<p><a name="eor"></a></p>
<h2>EOR : 逻辑异或</h2>
<p>(logical <font color="#0000FF">E</font>xclusive <font color="#0000FF">OR</font>)</p>
<pre>
  EOR{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 EOR op_2
</pre>
<code>EOR</code> 
将在两个操作数上进行逻辑异或，把结果放置到目的寄存器中；对反转特定的位有用。操作数 
1 是一个寄存器，操作数 2 
可以是一个寄存器，被移位的寄存器，或一个立即值:
<pre>
  EOR     R0, R0, #3              ; 反转 R0 中的位 0 和 1
</pre>
EOR 真值表(二者不同则结果为 1):
<pre>
  Op_1   Op_2   结果

  0      0      0
  0      1      1
  1      0      1
  1      1      0
　</pre>
<p><a name="mov"></a>
<h2>MOV : 传送</h2>
<p>(<font color="#0000FF">Mov</font>e)</p>
<pre>
  MOV{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;

                dest = op_1
</pre>
<code>MOV</code> 
从另一个寄存器、被移位的寄存器、或一个立即值装载一个值到目的寄存器。你可以指定相同的寄存器来实现 
NOP 指令的效果，你还可以专门移位一个寄存器:
<pre>
  MOV     R0, R0                  ; R0 = R0... NOP 指令

  MOV     R0, R0, LSL#3           ; R0 = R0 * 8
</pre>
如果 R15 
是目的寄存器，将修改程序计数器或标志。这用于返回到调用代码，方法是把连接寄存器的内容传送到 
R15:
<pre>
  MOV     PC, R14                 ; 退出到调用者

  MOVS    PC, R14                 ; 退出到调用者并恢复标志位
                                    <font color="red">(不遵从 32-bit 体系)</font>
　</pre>
<p><a name="mvn"></a>
<h2>MVN : 传送取反的值</h2>
<p>(<font color="#0000FF">M</font>o<font color="#0000FF">v</font>e<font color="#0000FF"> 
N</font>egative)</p>
<pre>
  MVN{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;

                dest = !op_1
</pre>
<code>MVN</code> 
从另一个寄存器、被移位的寄存器、或一个立即值装载一个值到目的寄存器。不同之处是在传送之前位被反转了，所以把一个被取反的值传送到一个寄存器中。这是逻辑非操作而不是算术操作，这个取反的值加 
1 才是它的取负的值:
<pre>
  MVN     R0, #4                  ; R0 = -5

  MVN     R0, #0                  ; R0 = -1
　</pre>
<p><a name="orr"></a>
<h2>ORR : 逻辑或</h2>
<p>(logical <font color="#0000FF">OR</font>)</p>
<pre>
  ORR{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 OR op_2
</pre>
<code>OR</code> 
将在两个操作数上进行逻辑或，把结果放置到目的寄存器中；对设置特定的位有用。操作数 
1 是一个寄存器，操作数 2 
可以是一个寄存器，被移位的寄存器，或一个立即值:
<pre>
  ORR     R0, R0, #3              ; 设置 R0 中位 0 和 1
</pre>
OR 真值表(二者中存在 1 则结果为 1):
<pre>
  Op_1   Op_2   结果

  0      0      0
  0      1      1
  1      0      1
  1      1      1
　</pre>
<p><a name="rsb"></a>
<h2>RSB : 反向减法</h2>
<p>(<font color="#0000FF">R</font>everse <font color="#0000FF">S</font>u<font color="#0000FF">b</font>traction)</p>
<pre>
  RSB{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_2 - op_1
</pre>
<code>SUB</code> 用操作数 <b>two </b>减去操作数 <b>one</b>，把结果放置到目的寄存器中。操作数 
1 是一个寄存器，操作数 2 
可以是一个寄存器，被移位的寄存器，或一个立即值:
<pre>
  RSB     R0, R1, R2              ; R0 = R2 - R1
  RSB     R0, R1, #256            ; R0 = 256 - R1
  RSB     R0, R2, R3,LSL#1        ; R0 = (R3 &lt;&lt; 1) - R2
</pre>
反向减法可以在有符号或无符号数上进行。
<p>&nbsp;　
<p><a name="rsc"></a>
<h2>RSC : 带借位的反向减法</h2>
<p>(<font color="#0000FF">R</font>everse <font color="#0000FF">S</font>ubtraction 
with <font color="#0000FF">C</font>arry)</p>
<pre>
  RSC{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_2 - op_1 - !carry
</pre>
同于 <code>SBC</code>，但倒换了两个操作数的前后位置。
<p>&nbsp;　
<p><a name="sbc"></a>
<h2>SBC : 带借位的减法</h2>
<p>(<font color="#0000FF">S</font>u<font color="#0000FF">b</font>traction with <font color="#0000FF">C</font>arry)</p>
<pre>
  SBC{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 - op_2 - !carry
</pre>
<code>SBC</code> 
做两个操作数的减法，把结果放置到目的寄存器中。它使用进位标志来表示借位，这样就可以做大于 
32 位的减法。<code>SUB</code> 和 <code>SBC</code> 
生成进位标志的方式不同于常规，如果需要借位则<b>清除</b>进位标志。所以，指令要对进位标志进行一个<b>非</b>操作 
- 在指令执行期间自动的反转此位。
<p>&nbsp;　
<p><a name="sub"></a>
<h2>SUB : 减法</h2>
<p>(<font color="#0000FF">Sub</font>traction)</p>
<pre>
  SUB{条件}{S}  &lt;dest&gt;, &lt;op 1&gt;, &lt;op 2&gt;

                dest = op_1 - op_2
</pre>
<code>SUB</code> 用操作数 <b>one </b>减去操作数<b></b><b> two</b>，把结果放置到目的寄存器中。操作数 
1 是一个寄存器，操作数 2 
可以是一个寄存器，被移位的寄存器，或一个立即值:
<pre>
  SUB     R0, R1, R2              ; R0 = R1 - R2
  SUB     R0, R1, #256            ; R0 = R1 - 256
  SUB     R0, R2, R3,LSL#1        ; R0 = R2 - (R3 &lt;&lt; 1)
</pre>
减法可以在有符号和无符号数上进行。
<p>　
<hr size="3">
<a href="index.html">回到目录页</a>

</body>

</html>
