<!doctype html public "-//W3C//DTD HTML 3.2//EN">

<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta http-equiv="Content-Language" content="zh-cn">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../global.css">
<title>伪指令</title>
</head>

<body TopMargin=0 bgcolor="#f0f0f0" text="#000000" link="#0022dd" vlink="#002288">
<!-- embest help header -->
<img src="../arm.gif" width=778 height=73 border=0>
<!-- embest help header -->
    
<table border="0" width="100%">
  <tr>
    <td align="center" width="100"></td>
    <td>
      <h1 align="center"><font color="#202020">伪指令</font></h1>
    </td>
    <td align="center" width="100"></td>
</table>
<ul>
  <li><a href="#adr">ADR</a></li>
  <li><a href="#adrl">ADRL</a></li>
  <li><a href="#align">ALIGN</a></li>
  <li><a href="#dcx">DCx</a></li>
  <li><a href="#equx">EQUx</a></li>
  <li><a href="#opt">OPT</a></li>
</ul>
<p>RISC OS 的 BASIC 
汇编器提供了一组伪指令。它们不是处理器实际上能理解的指令，但可以转换成它能理解的某种东西。它们的存在能使你的程序更加简单。
<p>&nbsp;</p>
<p><a name="adr"></a>
<h2>ADR : 装载地址</h2>
<p>(load <font color="#0000FF">Ad</font>d<font color="#0000FF">r</font>ess)</p>
<pre>
   ADR{后缀} &lt;寄存器&gt;, &lt;标号&gt;
</pre>
它把参照的地址装载到给定寄存器中:
<pre>   00008FE4                    OPT     l%
   00008FE4 E28F0004           ADR     R0, text
   00008FE8 EF000002           SWI     &quot;OS_Write0&quot;
   00008FEC E1A0F00E           MOV     PC, R14
   00008FF0                    .text
   00008FF0                    EQUS    &quot;Hello!&quot; + CHR$13 + CHR$10 + CHR$0
   00008FFC                    ALIGN
</pre>
<p>下列代码有完全相同的效果:
<pre>   00008FE4                    OPT     l%
   00008FE4 E28F0004           ADD     R0, R15, #4
   00008FE8 EF000002           SWI     &quot;OS_Write0&quot;
   00008FEC E1A0F00E           MOV     PC, R14
   00008FF0                    .text
   00008FF0                    EQUS    &quot;Hello!&quot; + CHR$13 + CHR$10 + CHR$0
   00008FFC                    ALIGN
</pre>
实际上，它们的反汇编将显示:
<pre>   *MemoryI 8FE4 +18
   00008FE4 :  E28F0004 : .. : ADR     R0,&amp;00008FF0
   00008FE8 :  EF000002 : ...? : SWI     &quot;OS_Write0&quot;
   00008FEC :  E1A0F00E : .? : MOV     PC,R14
   00008FF0 :  6C6C6548 : Hell : STCVSTL CP5,C6,[R12],#-&amp;120 ; =288
   00008FF4 :  0A0D216F : o!.. : BEQ     &amp;003515B8
   00008FF8 :  00000000 : .... : DCD     &amp;00000000
</pre>
<p>ADR 是一个很有用的指令，你不需要关心相对 R15 的偏移量(例如，我们为什么只加 
4?)，也不需要在一块代码上计算偏移量。可以简单的使用 <code>ADR 
Rx, label</code> 而汇编器将设法为你使用 ADD、SUB、MOV 或 MVN 
中最恰当的那个指令。限制因素是你的引用范围只能是在 4096 
字节中(不完全是真的，它典型的对 ADD 或 SUB 
使用被循环右移的立即值，但是为了参数的一致性，我们假定范围是 
4K)。</p>
　
<p>&nbsp;<a name="adrl"></a></p>
<h2>ADRL : 装载长地址</h2>
<p>(load <font color="#0000FF">Ad</font>d<font color="#0000FF">r</font>ess <font color="#0000FF">L</font>ong)</p>
<pre>
   ADRL{后缀} &lt;寄存器&gt;, &lt;标号&gt;
</pre>
&nbsp;BASIC 汇编器不支持它，但一些扩展支持它。
<p>ADRL 指令使用 ADR 和 ADD，或 ADR 和 SUB 
的一个组合，来生成一个更广大的可以到达的地址范围。但是它总是使用两个指令，所以可以尝试更加可运做的布置来重新组织你的那些可以使用普通的 
ADR 代码。
<p>还有，在一些汇编器中，用使用三个指令的 ADRX 
来定位更大的地址。
<p>　</p>
<p><a name="align"></a></p>
<h2>ALIGN : 对齐指针</h2>
<p>(<font color="#0000FF">ALIGN</font> pointers)</p>
<pre>
   ALIGN
</pre>
ALIGN 指令设置 <code>P%</code> (如果需要的话还有 <code>O%</code>)来在一个字边界上对齐。通常要求它跟随着一个字符串或者一个或多个字节的数据，并切应当在更远的代码被汇编之前使用它。
<p>BASIC 
汇编器非常聪明并且有经验，如果你疏忽了，它能为你处理对齐问题...
<pre>   00008FF4                    OPT     l%
   00008FF4 E28F0004           ADR     R0, text
   00008FF8 EF000002           SWI     &quot;OS_Write0&quot;
   00008FFC EA000004           B       carryon
   00009000                    .text
   00009000                    EQUS    &quot;unaligned text!!!&quot; + CHR$0
   00009012                    .carryon
   00009014 E1A0F00E           MOV     PC, R14
</pre>
<p><a name="dcx"></a>
<h2>DCx : 初始化数据存储</h2>
<pre>
   DCx &lt;值&gt;
</pre>
没有 DCx 指令。小‘x’表示一个可能的范围。它们是:
<pre>
   DCB    预备一个字节(8 位值)
   DCW    预备一个半字(16 位值)
   DCD    预备一个字(32 位值)
   DCS    按给出的字符串的要求预备直到 255 个的字符
</pre>
例如:
<pre>
   .start_counter
     DCB     1

   .pointer
     DCD     0

   .error_block
     DCD     17
     DCS     &quot;Uh-oh! It all went wrong!&quot; + CHR$0
     ALIGN
　</pre>
<p><a name="equx"></a>
<h2>EQUx : 初始化数据存储</h2>
<pre>
   EQUx &lt;值&gt;
</pre>
没有 EQUx 指令，小‘x’表示一个可能的范围。它们是:
<pre>
   EQUB   预备一个字节(8 位值)
   EQUW   预备一个半字(16 位值)
   EQUD   预备一个字(32 位值)
   EQUS   按给出的字符串的要求预备直到 255 个的字符
</pre>
简单的理解，除了名字不同之外与(上面的) DCx 
完全一样。你可以使用‘<code>=</code>’作为 EQUB 的简写。
<p>　
<p><a name="opt"></a></p>
<h2>OPT : 设置汇编器选项</h2>
<p>(set assembler <font color="#0000FF">Opt</font>ions)</p>
<pre>
   OPT &lt;值&gt;
</pre>
它设置各种汇编器选项。&nbsp;
<p>　
<hr size="3">
<a href="index.html">回到目录页</a>

</body>

</html>
